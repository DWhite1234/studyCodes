# 创建线程的两种方式

```java
1.实现接口(推荐)
    class Test implements Runable{
        
    }

2.继承Thread类
    class Test extends Thread{
    	//构造赋值,该值是当前线程的名字
        public Test(String name){
			super(name);
        }
    }
    
```

# 线程同步的两种方法

```java
//线程同步的要求,同步监视器必须为同一个引用类型,同一个对象

1.同步代码块
synchronized(同步监视器){
	....
}

2.同步方法,同步方法的同步监视器默认为this,要求this指代对象必须一致才能实现同步

test()

public synchronized void test(){
	....
}
```

## 实现同步的完整写法(2/4)

### 继承Thread

```java
public class TestThread {

    public static void main(String[] args) {
        ExtendThread f1 = new ExtendThread("一号窗口");
        ExtendThread f2 = new ExtendThread("二号窗口");
        ExtendThread f3 = new ExtendThread("三号窗口");
        ExtendThread f4 = new ExtendThread("四号窗口");

        f1.start();
        f2.start();
        f3.start();
        f4.start();
    }
}

class ExtendThread extends Thread {
    public ExtendThread(String name) {
        super(name);
    }

    static Object obj = new Object();
    static int num = 100;

    @Override
    public void run() {
        
        while (num>0) {
            sale();
            //同步代码块
//            synchronized (obj) {
//                if (num <=0) {
//                    return;
//                }
//                System.out.println(Thread.currentThread().getName() + "售出" + num + "号票,余票:" + --num);
//            }
        }
    }

    //同步方法
    private synchronized static void sale() {
        if (num <=0) {
            return;
        }
        System.out.println(Thread.currentThread().getName() + "售出" + num + "号票,余票:" + --num);
    }


}
```

### 实现Runable接口

```java
package day14.codes;

public class TestRunable implements Runnable {
    int num = 100;

    @Override
    public void run() {
        while (num > 0) {
            sale();
            //同步代码块
//            synchronized (this) {
//                if (num <= 0) {
//                    return;
//                }
//                System.out.println(Thread.currentThread().getName() + "售出" + num + "号票,余票:" + --num);
//            }
        }
    }

    //同步方法
    private synchronized void sale() {
        if (num <= 0) {
            return;
        }
        System.out.println(Thread.currentThread().getName() + "售出" + num + "号票,余票:" + --num);
    }

}

class Test3 {
    public static void main(String[] args) {
        TestRunable testRunable = new TestRunable();
        Thread f1 = new Thread(testRunable, "一号窗口");
        Thread f2 = new Thread(testRunable, "二号窗口");
        Thread f3 = new Thread(testRunable, "三号窗口");
        Thread f4 = new Thread(testRunable, "四号窗口");

        f1.start();
        f2.start();
        f3.start();
        f4.start();
    }
}

```

# 在多线程中使数据同步共享volatile

```java
//需要在多线程中共享的数据,直接加上volatile即可共享
volatile boolean flag = true;

原因:
	CPU将频繁使用的数据读到CPU的缓存,加了volatile就不会放缓存中,使得每次都是拿的最新的数据
```

# 多线程的常用方法

```java
    thread.setName("大白兔")//设置线程名
    thread.getName()//获取线程名
    thread.setPriority(1)//数值从1-10,数值越大,优先级越高,默认优先级是5  
    thread.isAlive()//查看线程是否处于活动状态
    Thread.sleep(1000)//线程睡眠,单位是ms,睡眠后丢失执行权,返回阻塞状态
    thread.join()//线程插队.不带参默认插队线程全部执行完后,放行.带参,插队线程在时间内插队,然后放行,单位ms
    Thread.yield()//线程礼让,返回就绪状态,仍有机会再次获得CPU调度权
    thread.setDaemon(true)//守护线程,当主线程结束,守护线程也自动结束,位置必须在线程开启前  
```

