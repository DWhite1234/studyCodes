# 普通成员内部类

```java

普通成员内部类：
1.外部类 只能使用 public default 修饰
2.内部类可以被四种权限修饰符修饰
3.内部类中不能有静态的属性 但是可以存在 静态的常量
4.内部类中不能有静态的方法
5.内部类中可以直接使用外部类中的资源 属性 方法  静态非静态都可以
10.内部类中如果存在和外部类同名的属性,直接使用外部类的同名属性 
	外部类名.this.属性
6.外部使用内部类的资源
      非静态资源  创建内部类对象才能访问
      静态资源  内部类名.属性名
7.在外部类的静态方法内 不能直接创建内部类对象
	不能直接new Inner();
8.在外部直接创建内部类对象的方式
 外部类名.内部类名  变量名 =  new 外部类对象.new 内部类对象();
   Person.Inner inner = new Person().new Inner();

9.内部类编译后 产生的字节码文件 命名规则
  外部类名$内部类名
   Person$Inner
  内部类也会生成独立的字节码文件

内部类的作用：
    1.可以对外部类的功能进行拓展 且 可以不被外界访问
    2.间接实现多继承  内部类与外部类都去继承一个类
```

# 静态成员内部类

```java
静态成员内部类：
1.声明方式  在外部类中 写 static class 类名{
} 
2.内部类中可以存在静态的属性
3.内部类中 不能直接使用外部类中的 非静态资源 需要创建外部类对象才能使用
4.在外部类的静态方法内 可以创建内部类对象
   可以通过 内部类对象 调用内部类中 非静态资源
           内部类名 调用  内部类中 静态资源
5.在外部类中直接创建内部类对象
   外部类名.内部类名 变量名 =  new 外部类名.内部类名();
   变量名：内部类对象
    Outer.Inner inner = new Outer.Inner();
6.内部类会生成独立的字节码文件  命名方式
  外部类名$内部类名
7.直接创建外部类对象 是否会引发 静态内部类的初始化?
    如果没有使用内部类中的资源 那不会进行内部类的初识化
    如果只是使用内部类中的资源  也不会触发外部类的初始化
```

# 局部内部类

```java
局部内部类：  参照 局部变量
1.如何声明局部内部类
   在方法中 新建一个类
2.局部内部类地位比较低  使用外部类的什么资源 由所在方法决定
      静态方法   可以使用外部类中的静态资源
      非静态方法  可以使用外部类中的所有资源
3.局部内部类中的不能有静态属性但是可以有静态的常量

4.使用内部类中的资源 需要先执行外部类的方法 创建内部类的对象
  通过内部类对象.相关资源

5.局部内部类也会生成独立的字节码文件  字节码文件的命名方式
  外部类名$序号内部类名  序号从1开始
  Outer$1Inner
  Outer$2Inner

6.当 局部内部类中的方法 使用 所在外部类的局部变量时  该局部变量 会自动被final修饰
  jdk1.8自动加final
```

# 匿名内部类

```java
匿名内部类：
    没有名字的内部类
什么作用：
    节约代码

如何创建匿名内部类：
    new 类(){}
    new 接口(){}
    1.创建了一个没有名字的匿名子类
    2.创建了该匿名子类对象

注意：
    1.匿名内部类 就是没有名字的局部内部类
    2.匿名内部类能使用外部类什么资源 要看所在的方法是否静态
        静态方法 只能使用静态资源
        非静态方法 能使用所有资源
    3.匿名内部类使用了所在方法的局部变量 则此变量 会被final修饰
    4.匿名内部类也会生成独立的字节码文件
      命名方式 外部类名$序号
      Test2$1.class
      Test2$2.class
      Test2$3.class
```

# 包装类

## 自动装箱与拆箱

```java
装箱：
    将基本类型数据 --->对应的包装类型

    自动装箱： 直接将基本数据类型  ---> 对应的包装类型
    			//方式一:自动类型提升
               Integer i3 = 10;
				//方式二:
			   Integer i=new Integer("20")
               

拆箱
   包装类型---->对应的基本数据类型
   		Integer i=new Integer("20");
        int i6 = i;

注意点:
1.包装类型是不可变对象
```

## 缓冲区

```java
缓冲区：
   [-128 ,127]
  if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);

byte
short
int
long  [-128,127]

double
flaot 没有缓冲区

Character [0,127]
Boolean  true false
```

## 包装类的方法

```java
1.将字符串转为基本数据类型
	byte  Byte.parseByte("12")
    short  Short.parseShort("23")
    int  Integer.parseInt("123")  必须是纯数字
    long Long.parseLong("12");
    float Float.parseFloat("12.34f"); f可以放 也可以不放  不能放 其他内 NumberFormatException
    double Double.parseDouble("12.34");
    char 使用字符串.charAt(下标)： 下标从0开始
        char c = "你好世界".charAt(3); //界
    boolean Boolean.parseBoolean("false"); 字符串只要是非true 就是false
    
2.将基本数据类型--->字符串
  1.字符串拼接的方法 20+"";
  2.  String.valueOf(int);
      String.valueOf(long);
      String.valueOf(double);
      String.valueOf(float);
      String.valueOf(char);    
```

