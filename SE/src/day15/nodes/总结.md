# sleep和wait的区别

```java
1.sleep是用Thread调用,wait是Object类的方法,是由同步监视对象调用
2.
    sleep(10):时间结束后回到运行状态,
    wait(10):时间结束后回到运行状态,
    wait():不能自己回到运行状态,必须由另一个线程唤醒
3.sleep不释放锁,wait释放锁
```

# sleep和yield的区别

```java
1.sleep从运行到阻塞,yield从运行到就绪
2.sleep调用后抛出异常,yield没有异常
3.都是由Thread调用
```

# 单例模式

## 饿汉式

```java
//构造器私有,提供已有的对象
public class Single {
    //饿汉式,类似于枚举
    private static Single single = new Single();

    private Single() {}

    public static Single getInstance() {
        return single;
    }
}
```

## 懒汉式

```java
//调用时才创建对象,但是在多线程的情况下,创建对象是线程不安全的,所以用同步锁
class HungrySingle {

    private static HungrySingle instance=null;

    private HungrySingle() {
    }

    public static synchronized HungrySingle getInstance() {
        if (instance == null) {
            instance = new HungrySingle();
        }
        return instance;
    }
}
```

# 线程的生命周期

```
      NEW, 尚未启动的线程   new RabbitThread();
      RUNNABLE, 正在运行的线程
      BLOCKED：
          zs 进入同步代码块
          zs媳妇 只能 在同步代码块外进行等待
      WAITING,
           当吧台的菜数 >10 厨师线程等待
      TIMED_WAITING,
          Thread.sleep(1000);
          join(1000);
          wait(1000);
      TERMINATED: 线程执行完毕任务 线程结束
```

# 哪些操作会释放线程锁

```java
1.wait()
2.线程正常执行任务,执行完释放锁
3.线程出现异常,释放锁	
```

# 实现线程安全的核心思想

```java
实现线程安全的核心思想:
	同步监视对象的同一性
1.同步代码块
	1.同步监视对象必须是同一个引用类型
	2.如果同步监视对象,是类本身,那么应该写成 [类名.class]
2.同步方法
	1.同步监视对象默认是this,必须保证this指向同一个对象
	2.同步方法对象如果是类本身,同时需要调用wait()是应该写成
	Single.class.wait(); //类名.class.wait()
	
注意点:
	wait()和notify()必须由同步监视对象来完成调用
	
```

## 经典案例

```java
//1.在主线程中创建了两个不同的线程对象,此时的如果是使用同步方法,this必然指代不一样
//为了是this指代一样必须引入第三方类

	Print print=new Print();

    PrintChar printChar = new PrintChar("字母线程",print);
    PrintNum printNum = new PrintNum("数字线程",print);

    printNum.start();
    printChar.start();



//第三方类应该写什么怎么确定,那就要看我们的矛盾点在哪里,在这个例子中是因为同步方法中,this无法统一,所以引入第三方类,那么我们就把矛盾转移,把两个线程类的同步方法放到第三方类中,这样一样都可以用第三方类的对象调用方法,完成了this 的统一
public class Print {
    private int count=1;

    public synchronized void printNum() {
        for (int i = 1; i <= 52; i++) {
            if (count % 3 == 0) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
            System.out.print(i+"\t");
            count++;
            this.notify();
        }
    }

    public synchronized void printChar() {
        for (char i = 'A'; i < 'z'; i++) {
            if (count % 3 != 0) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print(i+"\t");
            count++;
            this.notify();
        }
    }
}

//线程一
public class PrintChar extends Thread {
    Print print;
    public PrintChar(String name,Print print) {
        super(name);
        this.print=print;
    }

    @Override
    public void run() {
        print.printChar();
    }
}

//线程二
public class PrintNum extends Thread {
    Print print;

    public PrintNum(String name,Print print) {
        super(name);
        this.print=print;
    }

    @Override
    public void run() {
        print.printNum();
    }
}
```

