# JDK1.7HashMap源码流程

```
/*
第一次创建对象时  内部的成员变量
static final int DEFAULT_INITIAL_CAPACITY = 16;//默认的初始容量
最大容量
static final int MAXIMUM_CAPACITY = 1 << 30;
默认的加载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
底层哈西表内顺序表的类型
Entry<K,V>[] table;
Map集合内键值对的数量
transient int size;
capacity * load factor
容量 * 加载因子
阈值 开关
int threshold; 12
加载因子
final float loadFactor;

调用完无参构造
     会将阈值赋值为 12
     loadFactor 0.75F
     table = new Entry<>[16];

要求：底层的顺序表 必须是 2的次幂

数据添加：
    1.key 为null时
         首次添加 会将键值对 添加到 顺序表内下标为0的位置
         重复添加 会将 新的value 替换旧的value 并将旧的value 返回
    2.key 不为null
       2.1 指定位置第一次添加
            直接添加到指定位置

       2.2多次添加到指定位置 key 不重复
         七上：
               后追加的数据 会后来居上  直接添加到 顺序表的指定位置  之前存在的数据 要 变为 新添加数据的后一个元素
      2.3 多次添加到指定位置 key重复
 注意：
    扩容
        1.键值对的数量 >= 阈值
        2.即将添加位置 不能是null
        两个条件必须都满足
        扩容到原来的2倍
         if ((size >= threshold) && (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }
 */
```

# JDK1.8HashMap源码流程

```
/*
底层顺序表初始大小
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
底层顺序表最大容量
static final int MAXIMUM_CAPACITY = 1 << 30;
默认加载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
树化阈值
static final int TREEIFY_THRESHOLD = 8;
反树化阈值
static final int UNTREEIFY_THRESHOLD = 6;
最小树化容量
static final int MIN_TREEIFY_CAPACITY = 64;
底层顺序表类型
 transient Node<K,V>[] table;
 static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
  }
   static class Entry<K,V> implements Map.Entry<K,V> {
        final K key;
        V value;
        Entry<K,V> next;
        int hash;

        Entry(int h, K k, V v, Entry<K,V> n) {
        value = v;
        next = n;
        key = k;
        hash = h;
        }





集合内键值对数量
transient int size;
阈值
int threshold;
加载因子
final float loadFactor;
当调用无参构造器时
    只是将 默认的加载因子 赋值给 成员变量
    没有给底层的顺序表开辟空间

第一次进行数据添加
        1.开辟一个长度为16 的 Node[]
        2.当指定位置没有数据 直接填入
        3.向指定位置添加数据 hash一样 key 不一样
            会 在原有节点后进行追加
            八下
        4.向指定位置添加数据 hash一样 key 一样
            新的value会替换旧的value 并将旧的value 返回
        5.向指定位置添加数据 hash一样 key 不一样
            当指定位置的节点数量>=8
            并且 底层数组的长度 >=64
            才会进行树化
        6.当key 为null时  将数据添加到 下标为0的位置

 */
```

# HashMap总结

```java
1.创建对象时不会立刻分配空间，而是先初始化各种参数
 1.7：
 	DEFAULT_INITIAL_CAPACITY =16//初始容量
    MAXIMUM_CAPACITY= 1 << 30//最大容量
    DEFAULT_LOAD_FACTOR=0.75f//默认的加载因子
    threshold=12//阈值
        
    创建完会直接分配长度16的空间    
    
 1.8:
	底层顺序表初始大小
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
    底层顺序表最大容量
    static final int MAXIMUM_CAPACITY = 1 << 30;
    默认加载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    树化阈值
    static final int TREEIFY_THRESHOLD = 8;
    反树化阈值
    static final int UNTREEIFY_THRESHOLD = 6;
    最小树化容量
    static final int MIN_TREEIFY_CAPACITY = 64;

    创建完不会分配空间

2.添加key=null的流程
 0.
    1.8:    
        会先创建对象,分配长度为16的顺序表

 1.如果key为null,会把他的固定添加在顺序表的下标0的位置
 2.如果key!=null,会通过计算hashcode分配他在顺序表的位置[0-15]
 3.如果key相同了,会把原来的值返回,同时把新的值替换
 4.如果hashCode一样(在顺序表的位置一样),key不一样
 	1.7:七上
		1.会让最近添加的一个成为头结点,其他的链接在头结点后面
	1.8:八下
		1.会把最近添加的直接链接在最后一位
		2.树化(在顺序表的同一位置,链接超过8个节点,同时顺序表的最大容量为64时,会执行树化操作)
  5.扩容
    1.键值对的数量 >= 阈值
    2.即将添加位置 不能是null
      两个条件必须都满足
      扩容到原来的2倍          
            
注意点:
	1. 1.7的初始化数组为Entry,1.8的为Node
	2. 1.7的Entry节点类型中,成员变量hash没有加final
	   1.8的Node节点类型中,成员变量hash加了final
```

# Set与Map子类的关系

```java
HashSet--->HashMap
LinkedHashSet--->LinkedHashMap
TreeSet--->TreeMap

        
存储的时候,是将value存在key的位置,所以实现了唯一性        
Set的各个子类底层都分别调用了Map子类
```
# HashMap和Hashtable的区别
```text
不同
1.HashMap 1.8 第一次创建对象的时候  没有给底层的顺序表开辟空间
Hashtable   第一次创建对象的时候 给底层的顺序表开辟空间  长度为11  Entry<?,?>[]
2.HashMap key value都可以是null
Hashtable  key value都不可以是null
3.Hashtable 线程安全的  效率低
HashMap 线程不安全  效率高
4.Hashtable jdk1.0
HashMap jdk 1.2
同：
1.底层都是采用哈西表存储数据
2.都实现了Map接口
```

