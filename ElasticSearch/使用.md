# 1.核心数据类型
    字符串类型:text(分词) keyword(不分词)
    数值型:long,integer,short,byte,double,float
    日期类型:date
    布尔类型:boolean

# 2.构建建表
    PUT stu （stu类似于MySQL中的数据库名）
    {
      "mappings": {	（"mappings"可以理解为建表语句 create table关键字）
        "_doc":{		（"_doc"相当于MySQL中表名）
          "properties":{	（"properties"相当于建表语句中要指定字段及字段类型的关键字）"id":{           （" id "相当于具体某个字段）
              "type":"keyword"（"type"相当于要指定字段类型的关键字，"keyword "相当于字段的具体类型）
            },
            "name":{
              "type":"text"
            },
            "sex":{
              "type":"integer"
            },
            "birth":{
              "type":"date"
            }
          }
        }
      }
    }

# 3.插入数据
    PUT stu/_doc/1001  --> stu:数据库名  _doc:表名  1001:1001这条数据
    {
      "id":"1001",
      "name":"zs",
      "sex":"true",
      "age":"18"
    }
    post 不需要先构建表结构,直接插入数据即可,会自动创建表结构

# 4.获取数据
    GET stu/_doc/1001   ----> stu:数据库名  _doc:表名  1001:指定数据

# 查看索引-文档结构
    GET stu/_mappings

# IK分词器
    什么是IK分词器:将一组汉字 拆分成对应的单字 和词组

    为什么不用text
    因为text只会把所有的词拆分为一个一个的单字,所以不适合


    比如:"text":"我是一个程序员"
    结果:"我","是","一","个","程","序","员"

    所以使用IK分词器
    IK分词器有两种算法:
      ik_smart:
        最少切分(尽量不切分),可以看做是切分后的词加起来还是原来的一段词
      ik_max_word:
        最细粒度切分,将能切的词全部切分,加来一定原来的词数多

# 创建favo字段,使用ik分词器
    注意点:type必须设置为text可拆分,否则创建报错,同时一个mappings下只能有一个_doc不能有并列的_doc2
    PUT student
    {
      "mappings": {
        "_doc":{
          "properties":{
            "class_id":{
              "type":"keyword"
            },
            "stu_id":{
              "type":"keyword"
            },
            "name":{
              "type":"text"
            },
            "favo":{
              "type":"text",
              "analyzer":"ik_max_word"
            }
          }
        }
      }
    }

# es元数据查询
![es元数据查询](/pictures/es元数据查询.png)

# 全文检索(查看当前索引库下的所有文档)
    GET 索引/文档/_search   或者 GET 索引/_search

    例如:GET student/_doc/_search 或者GET student/_search

# 字段全值检索
    GET student/_search
    {
      "query":{
        "bool":{
          "filter":{
            "term":{
              "属性名":"属性值"
            }
          }
        }
      }
    }

    匹配规则:如果该属性使用的分词器,那么盖词会被切分,如果查询时指定的属性值,匹配不上切分的任意一个切分值,那么都会查询不到,就算盖词的确存在于属性值中

    比如:属性值为"唱跳" 只会切分为"唱","跳"
    如果使用"唱跳"去匹配,却匹配不上任意一个切分后的值,所以查询出来的是NULL,尽管他的值和原值一模一样

# 字段分词检索
    GET student/_search
    {
      "query":{
        "match":{
          "属性名":"属性值"
        }
      }
    }
    只要属性值的分词后的任意词能够匹配上就能查出数据


# 全值检索和分词检索结合使用
    GET student/_search
    {
      "query":{
        "bool":{
          "filter":{
            "term":{
              "属性名":"属性值"
            }
          },
          "must":[
            {
              "match":{
                "属性名":"属性值"
              }
            }
          ]
        }
      }
    }


    注意:
      1.两种查询条件必须同时满足才可以
      2.must是[] 套{},不要忘记[]


# 模糊查询
    GET student/_search
    {
      "query":{
        "fuzzy":{
          "属性名":"属性值"
        }
      }
    }


# 聚合查询
## 单条件聚合查询
    GET student/_search
    {
      "aggs":{
        "groupByClass":{
          "terms":{
            "field":"属性名",
            "size":3 (降序排序,取前几)
          }
        }
      }
    }
## 多条件聚合查询,各个条件互不影响,相当于多次单条件查询
    GET student/_search
    {
      "aggs":{
        "groupByClass":{
          "terms":{
            "field":"属性名",
            "size":3
          }
        },
        "groupById":{
          "field":"属性名",
          "size":3
        }
      }
    }  

# 分页检索
    GET student/_search
    {
      "from":0 (从第几条开始),
      "size":10 (每页显示几条)
    }        

# 创建别名
## 创建索引时创建别名
    PUT studeng
    {
      "aliases":{
        "别名":{}
      },
      "mappings":{
        "_doc":{
          "properties":{
            "id":{
              "type":"keyword"
            }
          }
        }
      }
    }
## 为已经存在的索引,添加别名
    POST _aliases
    {
      "actions":[
        {
          "add":{
            "index":"索因名称",
            "alias":"别名"
          }
        }
      ]
    }
注意:同一个索引可以设置多个别名,可以用来分组
# 删除别名
    POST _aliases
    {
      "actions":[
        {
          "remove":{
            "index":"索引名称",
            "alias":"别名"
          }
        }
      ]
    }

# 无缝切换别名
    POST _aliases
    {
      "actions":[
        "remove":{
          "index":"索引名称",
          "alias":"别名"
        },
        "add":{
          "index":"索引名称",
          "alias":"别名"
        }
      ]
    } 

# 查看别名列表
    GET _cat/_alias?v

# 使用别名查询索引
    GET 别名/_search           

# 创建模板
    PUT _template/模板名
    {
      "index-patterns":["movie*"]  (模板表达式,所有符合这个表达式的模板),
      "aliases":{
        "{index}-query":{},     ({index}表示引用当前模板名) 这个可以用来设置当前模板的别名  
        "movie-query":{}        这个可以用来设置多个索引的所属组
      },
      "mappings":{
        "_doc":{
          "properties":{
            "id":{
              "type":"keyword"
            }
          }
        }
      }
    }

# 删除模板
    DELETE _template/模板名

# 查看指定模板的详细情况
    GET _template/模板名

# 查看所有模板
    GET _cat/templates?v
